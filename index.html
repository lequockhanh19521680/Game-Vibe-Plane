<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    <title>Stellar Drift: Singularity</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Exo+2:wght@400;700&display=swap"
      rel="stylesheet"
    />
    <style>
      :root {
        --primary-color: #00ffff;
        --danger-color: #ff4444;
        --energy-color: #aa66cc;
        --highlight-color: #ffbb33;
        --missile-color: #f48fb1;
        --crystal-color: #40c4ff;
      }

      body,
      html {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
        background-color: #000;
        font-family: "Exo 2", sans-serif;
        color: #fff;
        user-select: none;
        -webkit-user-select: none;
        touch-action: none;
      }

      #game-canvas {
        display: block;
        background-color: #050510; /* Darker base */
        cursor: none;
        transition: transform 0.1s ease-out;
      }

      #game-canvas.shake {
        animation: screenShake 0.3s ease-in-out;
      }

      #ui-container {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        text-align: center;
        pointer-events: none;
      }

      .ui-element {
        pointer-events: auto;
        background: rgba(15, 15, 30, 0.6);
        padding: 2rem 3rem;
        border-radius: 20px;
        backdrop-filter: blur(12px);
        -webkit-backdrop-filter: blur(12px);
        border: 1px solid rgba(0, 255, 255, 0.25);
        box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
        animation: fadeIn 1s ease-out;
        display: flex;
        flex-direction: column;
        align-items: center;
      }

      h1,
      h2 {
        margin: 0;
        font-weight: 700;
        text-transform: uppercase;
        letter-spacing: 4px;
        color: var(--primary-color);
        text-shadow: 0 0 5px var(--primary-color), 0 0 15px var(--primary-color),
          0 0 30px var(--primary-color);
        line-height: 1.1;
      }

      h1 {
        font-size: 3.5rem;
        margin-bottom: 0rem;
      }
      h2 {
        font-size: 2.8rem;
        margin-bottom: 0.5rem;
      }

      p {
        margin: 0.5rem 0 1.5rem 0;
        color: #ddd;
        font-size: 1.1rem;
        max-width: 450px;
        line-height: 1.6;
      }

      button {
        font-family: "Exo 2", sans-serif;
        background: transparent;
        border: 2px solid var(--primary-color);
        color: var(--primary-color);
        padding: 1rem 2.5rem;
        font-size: 1.2rem;
        border-radius: 12px;
        cursor: pointer;
        text-transform: uppercase;
        transition: all 0.3s ease;
        box-shadow: inset 0 0 10px rgba(0, 255, 255, 0.3),
          0 0 10px rgba(0, 255, 255, 0.3);
        animation: pulse 2.5s infinite;
      }

      button:hover {
        background: var(--primary-color);
        color: #0a0a1a;
        box-shadow: 0 0 25px var(--primary-color), 0 0 50px var(--primary-color);
        transform: scale(1.05);
        animation: none;
      }

      #score-container {
        position: absolute;
        top: 20px;
        left: 20px;
        text-align: left;
        opacity: 0;
        transition: opacity 0.5s;
      }

      #score-display,
      #highscore-display,
      #survival-display {
        font-size: 1.8rem;
        font-weight: 700;
        text-shadow: 0 0 8px var(--primary-color);
        color: var(--primary-color);
      }
      #highscore-display {
        font-size: 1rem;
        color: var(--highlight-color);
        text-shadow: 0 0 8px var(--highlight-color);
      }
      #survival-display {
        font-size: 1.2rem;
        color: var(--energy-color);
        text-shadow: 0 0 8px var(--energy-color);
      }

      #game-over-screen {
        display: none;
        flex-direction: column;
        gap: 1rem;
      }

      #final-score {
        font-size: 1.8rem;
        color: var(--highlight-color);
        text-shadow: 0 0 8px var(--highlight-color);
        margin-bottom: 0;
      }
      #final-time {
        font-size: 1.4rem;
        color: var(--energy-color);
        text-shadow: 0 0 8px var(--energy-color);
        margin-bottom: 0.5rem;
      }
      #new-highscore-msg {
        font-size: 1.2rem;
        color: var(--primary-color);
        text-shadow: 0 0 8px var(--primary-color);
        display: none; /* Hidden by default */
      }

      #event-text {
        position: absolute;
        top: 25%;
        left: 50%;
        transform: translateX(-50%);
        font-size: 2.5rem;
        color: var(--highlight-color);
        text-shadow: 0 0 15px var(--highlight-color);
        opacity: 0;
        transition: opacity 0.5s ease-in-out;
        text-transform: uppercase;
        font-weight: 700;
        pointer-events: none;
      }

      /* Keyframes */
      @keyframes fadeIn {
        from {
          opacity: 0;
          transform: scale(0.9);
        }
        to {
          opacity: 1;
          transform: scale(1);
        }
      }
      @keyframes pulse {
        0% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.03);
        }
        100% {
          transform: scale(1);
        }
      }
      @keyframes screenShake {
        0%,
        100% {
          transform: translate(0, 0);
        }
        25% {
          transform: translate(5px, 5px);
        }
        50% {
          transform: translate(-5px, -5px);
        }
        75% {
          transform: translate(5px, -5px);
        }
      }
    </style>
  </head>
  <body>
    <canvas id="game-canvas"></canvas>

    <div id="ui-container">
      <div id="score-container">
        <div id="score-display">Score: 0</div>
        <div id="highscore-display">High Score: 0</div>
        <div id="survival-display">Time: 0:00</div>
      </div>

      <div id="event-text"></div>

      <div id="start-screen" class="ui-element">
        <h1>Stellar Drift</h1>
        <h2>SINGULARITY</h2>
        <p>
          Move to score points. Avoid asteroids, black holes & missiles. Survive
          as long as possible!
        </p>
        <button id="start-button">Start Battle</button>
      </div>

      <div id="game-over-screen" class="ui-element">
        <h2>Game Over</h2>
        <p id="final-score">Your score: 0</p>
        <p id="final-time">Survival time: 0:00</p>
        <p id="new-highscore-msg">New High Score!</p>
        <button id="restart-button">Try Again</button>
      </div>
    </div>

    <script src="gameConfig.js"></script>
    <script>
      // --- Audio System ---
      let audioContext;

      function initAudioSystem() {
        if (!audioContext) {
          audioContext = new (window.AudioContext ||
            window.webkitAudioContext)();
        }
        if (audioContext.state === "suspended") {
          audioContext.resume();
        }
      }

      // Generate synthetic sounds using Web Audio API
      function createSound(frequency, duration, type = "sine", volume = 0.3) {
        if (!audioContext) return;

        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();

        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);

        oscillator.frequency.setValueAtTime(
          frequency,
          audioContext.currentTime
        );
        oscillator.type = type;

        gainNode.gain.setValueAtTime(0, audioContext.currentTime);
        gainNode.gain.linearRampToValueAtTime(
          volume,
          audioContext.currentTime + 0.01
        );
        gainNode.gain.exponentialRampToValueAtTime(
          0.001,
          audioContext.currentTime + duration
        );

        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + duration);

        return oscillator;
      }

      function createExplosionSound() {
        const duration = 0.4;
        const frequencies = [80, 120, 200, 350];

        frequencies.forEach((freq, index) => {
          setTimeout(() => {
            createSound(
              freq,
              duration * 0.8,
              "sawtooth",
              GAME_CONFIG.audio.volumes.explosion
            );
          }, index * 20);
        });
      }

      function createLaserSound() {
        createSound(800, 0.1, "square", GAME_CONFIG.audio.volumes.laser);
        setTimeout(() => {
          createSound(
            1200,
            0.2,
            "sawtooth",
            GAME_CONFIG.audio.volumes.laser * 0.8
          );
        }, 100);
      }

      function createMissileSound() {
        createSound(200, 0.3, "sawtooth", GAME_CONFIG.audio.volumes.missile);
      }

      function createButtonHoverSound() {
        createSound(600, 0.1, "sine", GAME_CONFIG.audio.volumes.buttonHover);
      }

      function createCollisionSound() {
        createSound(250, 0.15, "square", GAME_CONFIG.audio.volumes.collision);
        setTimeout(() => {
          createSound(
            400,
            0.1,
            "triangle",
            GAME_CONFIG.audio.volumes.collision * 0.67
          );
        }, 50);
      }

      function createWarningSound() {
        createSound(1100, 0.08, "sine", GAME_CONFIG.audio.volumes.warning);
        setTimeout(() => {
          createSound(1100, 0.08, "sine", GAME_CONFIG.audio.volumes.warning);
        }, 120);
      }

      function createScoreSound() {
        createSound(500, 0.1, "sine", GAME_CONFIG.audio.volumes.score);
        setTimeout(() => {
          createSound(700, 0.1, "sine", GAME_CONFIG.audio.volumes.score * 0.75);
        }, 100);
      }

      function createPowerUpSound() {
        createSound(440, 0.2, "sine", GAME_CONFIG.audio.volumes.powerup);
        setTimeout(() => {
          createSound(
            550,
            0.2,
            "sine",
            GAME_CONFIG.audio.volumes.powerup * 0.83
          );
        }, 100);
        setTimeout(() => {
          createSound(
            660,
            0.2,
            "sine",
            GAME_CONFIG.audio.volumes.powerup * 0.67
          );
        }, 200);
      }

      function createBlackHoleSound() {
        createSound(100, 0.8, "sine", GAME_CONFIG.audio.volumes.blackhole);
        setTimeout(() => {
          createSound(
            80,
            0.6,
            "triangle",
            GAME_CONFIG.audio.volumes.blackhole * 0.67
          );
        }, 200);
      }

      function createBlackHoleGrowthSound() {
        createSound(90, 0.5, "sine", GAME_CONFIG.audio.volumes.blackholeGrowth);
      }

      function createBlackHoleDestroySound() {
        createSound(
          120,
          0.7,
          "triangle",
          GAME_CONFIG.audio.volumes.blackholeDestroy
        );
        setTimeout(() => {
          createSound(
            60,
            0.4,
            "square",
            GAME_CONFIG.audio.volumes.blackholeDestroy * 0.8
          );
        }, 100);
      }

      function createFragmentHitSound() {
        createSound(800, 0.15, "square", GAME_CONFIG.audio.volumes.fragmentHit);
        createSound(
          1200,
          0.1,
          "triangle",
          GAME_CONFIG.audio.volumes.fragmentHit * 0.6
        );
      }

      function createLaserMineSound() {
        createSound(600, 0.3, "sawtooth", GAME_CONFIG.audio.volumes.laserMine);
        setTimeout(() => {
          createSound(
            900,
            0.2,
            "sine",
            GAME_CONFIG.audio.volumes.laserMine * 0.7
          );
        }, 50);
      }

      function createWormholeSound() {
        createSound(150, 0.6, "sine", GAME_CONFIG.audio.volumes.wormhole);
        createSound(
          300,
          0.4,
          "triangle",
          GAME_CONFIG.audio.volumes.wormhole * 0.5
        );
      }

      function createShieldSound() {
        createSound(400, 0.4, "sine", GAME_CONFIG.audio.volumes.shield);
        createSound(
          600,
          0.3,
          "triangle",
          GAME_CONFIG.audio.volumes.shield * 0.7
        );
      }

      function createFreezeSound() {
        createSound(250, 0.5, "sine", GAME_CONFIG.audio.volumes.freeze);
        setTimeout(() => {
          createSound(
            180,
            0.3,
            "triangle",
            GAME_CONFIG.audio.volumes.freeze * 0.6
          );
        }, 100);
      }

      let backgroundMusicInterval;
      function startBackgroundMusic() {
        if (backgroundMusicInterval) clearInterval(backgroundMusicInterval);
        const frequencies = GAME_CONFIG.audio.backgroundMusic.frequencies;
        let currentIndex = 0;

        backgroundMusicInterval = setInterval(() => {
          if (isGameRunning && audioContext) {
            createSound(
              frequencies[currentIndex],
              GAME_CONFIG.audio.backgroundMusic.duration,
              "sine",
              GAME_CONFIG.audio.volumes.backgroundMusic
            );
            currentIndex = (currentIndex + 1) % frequencies.length;
          }
        }, GAME_CONFIG.audio.backgroundMusic.interval);
      }

      function stopBackgroundMusic() {
        if (backgroundMusicInterval) {
          clearInterval(backgroundMusicInterval);
          backgroundMusicInterval = null;
        }
      }

      function playSound(soundType) {
        initAudioSystem();

        switch (soundType) {
          case "explosion":
            createExplosionSound();
            break;
          case "laser":
            createLaserSound();
            break;
          case "missile":
            createMissileSound();
            break;
          case "buttonHover":
            createButtonHoverSound();
            break;
          case "collision":
            createCollisionSound();
            break;
          case "warning":
            createWarningSound();
            break;
          case "backgroundMusic":
            startBackgroundMusic();
            break;
          case "score":
            createScoreSound();
            break;
          case "powerup":
            createPowerUpSound();
            break;
          case "blackhole":
            createBlackHoleSound();
            break;
          case "blackholeGrowth":
            createBlackHoleGrowthSound();
            break;
          case "blackholeDestroy":
            createBlackHoleDestroySound();
            break;
          case "fragmentHit":
            createFragmentHitSound();
            break;
          case "laserMine":
            createLaserMineSound();
            break;
          case "wormhole":
            createWormholeSound();
            break;
          case "shield":
            createShieldSound();
            break;
          case "freeze":
            createFreezeSound();
            break;
        }
      }

      // --- Constants & Variables ---
      const canvas = document.getElementById("game-canvas");
      const ctx = canvas.getContext("2d");
      const uiElements = {
        startScreen: document.getElementById("start-screen"),
        gameOverScreen: document.getElementById("game-over-screen"),
        scoreContainer: document.getElementById("score-container"),
        scoreDisplay: document.getElementById("score-display"),
        highscoreDisplay: document.getElementById("highscore-display"),
        survivalDisplay: document.getElementById("survival-display"),
        finalScoreEl: document.getElementById("final-score"),
        finalTimeEl: document.getElementById("final-time"),
        newHighscoreMsg: document.getElementById("new-highscore-msg"),
        eventText: document.getElementById("event-text"),
      };
      const startButton = document.getElementById("start-button");
      const restartButton = document.getElementById("restart-button");

      let width, height;
      let player,
        stars,
        asteroids,
        particles,
        lasers,
        blackHoles,
        missiles,
        laserMines,
        crystalClusters,
        fragments,
        warnings;
      let mouse = { x: 0, y: 0 },
        prevMouse = { x: 0, y: 0 };
      let score = 0,
        highScore = 0;
      let gameStartTime = 0,
        survivalTime = 0;
      let animationFrameId;
      let timers = {
        asteroid: 0,
        difficulty: 0,
        laser: 0,
        blackHole: 0,
        missile: 0,
        mine: 0,
        crystal: 0,
      };
      let spawnInterval = GAME_CONFIG.difficulty.baseSpawnInterval;
      let isGameRunning = false;
      let globalSpeedMultiplier = GAME_CONFIG.difficulty.baseSpeed;
      let nebulae = [];
      let nextEventScore = 1000;
      let eventActive = { type: null, endTime: 0 };

      // --- Game Object Classes ---
      class Player {
        constructor(x, y, radius, color) {
          this.x = x;
          this.y = y;
          this.radius = radius;
          this.color = color;
          this.trail = [];
          this.velocity = { x: 0, y: 0 };
        }
        draw() {
          this.trail.forEach((part) => {
            ctx.beginPath();
            ctx.arc(part.x, part.y, part.radius, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(0, 255, 255, ${part.alpha})`;
            ctx.fill();
          });
          ctx.save();
          ctx.translate(this.x, this.y);
          ctx.beginPath();
          ctx.moveTo(0, -this.radius);
          ctx.lineTo(this.radius * 0.8, this.radius * 0.8);
          ctx.lineTo(-this.radius * 0.8, this.radius * 0.8);
          ctx.closePath();
          const shadowColor = this.color;
          ctx.shadowColor = shadowColor;
          ctx.shadowBlur = 15;
          ctx.fillStyle = this.color;
          ctx.fill();
          ctx.strokeStyle = "#fff";
          ctx.lineWidth = 2;
          ctx.stroke();
          ctx.restore();
        }
        update() {
          // Apply velocity from external forces like gravity
          this.x += this.velocity.x;
          this.y += this.velocity.y;
          // Dampen velocity over time (friction)
          this.velocity.x *= GAME_CONFIG.player.friction;
          this.velocity.y *= GAME_CONFIG.player.friction;

          // Responsive but smooth controls for precision feel
          const ease = GAME_CONFIG.player.responsiveness;
          this.x += (mouse.x - this.x) * ease;
          this.y += (mouse.y - this.y) * ease;

          // Keep player within screen bounds
          this.x = Math.max(this.radius, Math.min(width - this.radius, this.x));
          this.y = Math.max(
            this.radius,
            Math.min(height - this.radius, this.y)
          );

          this.trail.push({
            x: this.x,
            y: this.y + 10,
            radius: this.radius / 3,
            alpha: 1,
          });
          // Limit trail length for performance
          if (this.trail.length > GAME_CONFIG.player.trailLength) {
            this.trail.shift();
          }

          for (let i = this.trail.length - 1; i >= 0; i--) {
            this.trail[i].alpha -= GAME_CONFIG.player.trailFadeSpeed;
            this.trail[i].radius -= 0.1;
            if (this.trail[i].alpha <= 0) this.trail.splice(i, 1);
          }
          this.draw();
        }
      }

      class Fragment {
        constructor(x, y, velocity) {
          this.x = x;
          this.y = y;
          this.radius =
            GAME_CONFIG.fragments.minRadius +
            Math.random() *
              (GAME_CONFIG.fragments.maxRadius -
                GAME_CONFIG.fragments.minRadius);
          this.velocity = velocity;
          this.color = GAME_CONFIG.fragments.color;
          this.life =
            GAME_CONFIG.fragments.minLife +
            Math.random() *
              (GAME_CONFIG.fragments.maxLife - GAME_CONFIG.fragments.minLife);
          this.alpha = 1;
          this.rotation = Math.random() * Math.PI * 2;
          this.rotationSpeed =
            (Math.random() - 0.5) * GAME_CONFIG.fragments.rotationSpeed;
          this.lethal = false; // Regular fragments are not lethal
        }
      }

      class MissileFragment {
        constructor(x, y, velocity) {
          this.x = x;
          this.y = y;
          this.radius =
            GAME_CONFIG.fragments.missileFragments.minRadius +
            Math.random() *
              (GAME_CONFIG.fragments.missileFragments.maxRadius -
                GAME_CONFIG.fragments.missileFragments.minRadius);
          this.velocity = velocity;
          this.color = GAME_CONFIG.fragments.missileFragments.color;
          this.life =
            GAME_CONFIG.fragments.missileFragments.minLife +
            Math.random() *
              (GAME_CONFIG.fragments.missileFragments.maxLife -
                GAME_CONFIG.fragments.missileFragments.minLife);
          this.alpha = 1;
          this.rotation = Math.random() * Math.PI * 2;
          this.rotationSpeed = (Math.random() - 0.5) * 0.2;
          this.lethal = GAME_CONFIG.fragments.missileFragments.lethal;
        }

        draw() {
          ctx.save();
          ctx.globalAlpha = this.alpha;
          ctx.translate(this.x, this.y);
          ctx.rotate(this.rotation);
          ctx.beginPath();
          ctx.rect(
            -this.radius / 2,
            -this.radius / 2,
            this.radius,
            this.radius
          );
          ctx.fillStyle = this.color;
          ctx.shadowColor = this.color;
          ctx.shadowBlur = 8;
          ctx.fill();
          // Add danger glow for lethal fragments
          if (this.lethal) {
            ctx.strokeStyle = "#ff0088";
            ctx.lineWidth = 1;
            ctx.stroke();
          }
          ctx.restore();
        }

        update() {
          this.x += this.velocity.x;
          this.y += this.velocity.y;
          this.velocity.y += GAME_CONFIG.fragments.gravity;
          this.velocity.x *= GAME_CONFIG.fragments.airResistance;
          this.velocity.y *= GAME_CONFIG.fragments.airResistance;
          this.rotation += this.rotationSpeed;

          this.life--;
          this.alpha = Math.max(0, this.life / 120);

          return this.life <= 0;
        }

        draw() {
          ctx.save();
          ctx.globalAlpha = this.alpha;
          ctx.translate(this.x, this.y);
          ctx.rotate(this.rotation);
          ctx.beginPath();
          ctx.rect(
            -this.radius / 2,
            -this.radius / 2,
            this.radius,
            this.radius
          );
          ctx.fillStyle = this.color;
          ctx.shadowColor = this.color;
          ctx.shadowBlur = 5;
          ctx.fill();
          ctx.restore();
        }

        update() {
          this.x += this.velocity.x;
          this.y += this.velocity.y;
          this.velocity.y += GAME_CONFIG.fragments.gravity;
          this.velocity.x *= GAME_CONFIG.fragments.airResistance;
          this.velocity.y *= GAME_CONFIG.fragments.airResistance;
          this.rotation += this.rotationSpeed;

          this.life--;
          this.alpha = Math.max(0, this.life / 150);

          this.draw();
        }
      }

      class Warning {
        constructor(x, y, type, duration = 120) {
          this.x = x;
          this.y = y;
          this.type = type; // 'blackhole' or 'missile'
          this.duration = duration;
          this.timer = 0;
          this.radius = GAME_CONFIG.ui.warning.radius;
          this.alpha = 0;
        }

        draw() {
          ctx.save();
          ctx.globalAlpha = this.alpha;
          ctx.translate(this.x, this.y);

          // Pulsing warning circle
          const pulse =
            Math.sin(this.timer * GAME_CONFIG.ui.warning.pulseSpeed) * 0.5 +
            0.5;
          const currentRadius =
            this.radius + pulse * GAME_CONFIG.ui.warning.pulseIntensity;

          ctx.beginPath();
          ctx.arc(0, 0, currentRadius, 0, Math.PI * 2);
          ctx.strokeStyle = this.type === "blackhole" ? "#aa66cc" : "#f48fb1";
          ctx.lineWidth = 3;
          ctx.setLineDash([5, 5]);
          ctx.stroke();
          ctx.setLineDash([]);

          // Warning symbol
          ctx.fillStyle = this.type === "blackhole" ? "#aa66cc" : "#f48fb1";
          ctx.font = "bold 20px Arial";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText("!", 0, 0);

          ctx.restore();
        }

        update() {
          this.timer++;

          // Fade in and out
          if (this.timer < GAME_CONFIG.ui.warning.fadeInTime) {
            this.alpha = this.timer / GAME_CONFIG.ui.warning.fadeInTime;
          } else if (
            this.timer >
            this.duration - GAME_CONFIG.ui.warning.fadeOutTime
          ) {
            this.alpha =
              (this.duration - this.timer) / GAME_CONFIG.ui.warning.fadeOutTime;
          } else {
            this.alpha = 1;
          }

          this.draw();
        }
      }

      class Asteroid {
        constructor(x, y, radius, color, velocity) {
          this.x = x;
          this.y = y;
          this.radius = radius;
          this.color = color;
          this.velocity = velocity;
          this.shapePoints = this.createShape();
          this.isFragment = false;

          // Random movement patterns for diversity
          this.movementPattern = Math.random();
          this.rotationSpeed = (Math.random() - 0.5) * 0.05;
          this.rotation = 0;
          this.wobbleAmount = Math.random() * 0.5;
          this.wobbleSpeed = Math.random() * 0.1;
          this.wobblePhase = Math.random() * Math.PI * 2;
          this.timer = 0;

          // Occasional direction changes
          this.changeDirectionTimer = 60 + Math.random() * 180; // 1-4 seconds
          this.originalVelocity = { ...velocity };
        }
        createShape() {
          const p = [];
          const s = 7 + ~~(Math.random() * 5);
          for (let i = 0; i < s; i++) {
            const a = (i / s) * Math.PI * 2,
              r = this.radius * (0.7 + Math.random() * 0.3);
            p.push({ x: Math.cos(a) * r, y: Math.sin(a) * r });
          }
          return p;
        }
        draw() {
          ctx.save();
          ctx.translate(this.x, this.y);
          ctx.rotate(this.rotation);
          ctx.beginPath();
          ctx.moveTo(this.shapePoints[0].x, this.shapePoints[0].y);
          for (let i = 1; i < this.shapePoints.length; i++) {
            ctx.lineTo(this.shapePoints[i].x, this.shapePoints[i].y);
          }
          ctx.closePath();
          ctx.shadowColor = this.color;
          ctx.shadowBlur = 10;
          ctx.strokeStyle = this.color;
          ctx.lineWidth = 3;
          ctx.stroke();
          ctx.restore();
        }
        update() {
          this.timer++;
          this.rotation += this.rotationSpeed;

          // Apply different movement patterns for unpredictability
          if (!this.isFragment) {
            if (this.movementPattern < 0.6) {
              // Straight movement (60%)
              this.x += this.velocity.x;
              this.y += this.velocity.y;
            } else if (this.movementPattern < 0.8) {
              // Wobbling movement (20%)
              const wobble =
                Math.sin(this.timer * this.wobbleSpeed + this.wobblePhase) *
                this.wobbleAmount;
              this.x += this.velocity.x + Math.sin(this.rotation) * wobble;
              this.y += this.velocity.y + Math.cos(this.rotation) * wobble;
            } else if (this.movementPattern < 0.9) {
              // Spiral movement (10%)
              const spiralRadius = Math.sin(this.timer * 0.02) * 2;
              this.x +=
                this.velocity.x + Math.cos(this.timer * 0.1) * spiralRadius;
              this.y +=
                this.velocity.y + Math.sin(this.timer * 0.1) * spiralRadius;
            } else {
              // Erratic movement (10%)
              const jitter = 0.5;
              this.x += this.velocity.x + (Math.random() - 0.5) * jitter;
              this.y += this.velocity.y + (Math.random() - 0.5) * jitter;
            }

            // Random direction changes for some asteroids
            this.changeDirectionTimer--;
            if (this.changeDirectionTimer <= 0 && Math.random() < 0.3) {
              const changeAmount = 0.3;
              this.velocity.x += (Math.random() - 0.5) * changeAmount;
              this.velocity.y += (Math.random() - 0.5) * changeAmount;
              this.changeDirectionTimer = 120 + Math.random() * 240; // 2-6 seconds
            }
          } else {
            // Fragment movement
            this.x += this.velocity.x;
            this.y += this.velocity.y;
            this.velocity.x *= GAME_CONFIG.asteroids.fragmentSpeed;
            this.velocity.y *= GAME_CONFIG.asteroids.fragmentSpeed;
          }

          this.draw();
        }
      }
      class Particle {
        constructor(x, y, radius, color, velocity) {
          this.x = x;
          this.y = y;
          this.radius = radius;
          this.color = color;
          this.velocity = velocity;
          this.alpha = 1;
        }
        draw() {
          ctx.save();
          ctx.globalAlpha = this.alpha;
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
          ctx.shadowColor = this.color;
          ctx.shadowBlur = 10;
          ctx.fillStyle = this.color;
          ctx.fill();
          ctx.restore();
        }
        update() {
          this.x += this.velocity.x;
          this.y += this.velocity.y;
          this.alpha -= GAME_CONFIG.visual.particles.fadeSpeed;
          this.draw();
        }
      }
      class Star {
        constructor(x, y, radius, layer) {
          this.x = x;
          this.y = y;
          this.radius = radius;
          this.layer = layer;
          this.velocity = 0.2 + layer * 0.5;
          this.alpha = 0.5 + layer * 0.5;
        }
        draw() {
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
          ctx.fillStyle = `rgba(255, 255, 255, ${this.alpha})`;
          ctx.fill();
        }
        update() {
          this.y += this.velocity * globalSpeedMultiplier;
          if (this.y - this.radius > height) {
            this.y = 0 - this.radius;
            this.x = Math.random() * width;
          }
          this.draw();
        }
      }
      class Laser {
        constructor(targetPlayer = false) {
          this.targetPlayer = targetPlayer;
          const edge = Math.floor(Math.random() * 4);
          if (edge === 0) {
            this.x = 0;
            this.y = Math.random() * height;
          } else if (edge === 1) {
            this.x = width;
            this.y = Math.random() * height;
          } else if (edge === 2) {
            this.x = Math.random() * width;
            this.y = 0;
          } else {
            this.x = Math.random() * width;
            this.y = height;
          }

          if (this.targetPlayer && player) {
            // Aim at player's position
            this.angle = Math.atan2(player.y - this.y, player.x - this.x);
          } else {
            // Random angle
            this.angle = Math.random() * Math.PI * 2;
          }

          this.timer = 0;
          this.maxTime = GAME_CONFIG.lasers.warningTime;
          this.fired = false;
        }
        drawWarning() {
          ctx.save();
          ctx.globalAlpha = this.timer / this.maxTime;
          ctx.beginPath();
          const len = width + height;
          ctx.moveTo(
            this.x - Math.cos(this.angle) * len,
            this.y - Math.sin(this.angle) * len
          );
          ctx.lineTo(
            this.x + Math.cos(this.angle) * len,
            this.y + Math.sin(this.angle) * len
          );
          ctx.strokeStyle = "var(--danger-color)";
          ctx.lineWidth = 4;
          ctx.shadowColor = "var(--danger-color)";
          ctx.shadowBlur = 15;
          ctx.stroke();
          ctx.restore();
        }
        drawBeam() {
          ctx.save();
          ctx.beginPath();
          const len = width + height;
          ctx.moveTo(
            this.x - Math.cos(this.angle) * len,
            this.y - Math.sin(this.angle) * len
          );
          ctx.lineTo(
            this.x + Math.cos(this.angle) * len,
            this.y + Math.sin(this.angle) * len
          );
          ctx.strokeStyle = "#fff";
          ctx.lineWidth = 15;
          ctx.shadowColor = "var(--danger-color)";
          ctx.shadowBlur = 20;
          ctx.stroke();
          ctx.restore();
        }
        update() {
          this.timer++;
          if (this.timer < this.maxTime) {
            this.drawWarning();
          } else {
            if (!this.fired) {
              triggerScreenShake(GAME_CONFIG.visual.screenShake.laserIntensity);
              this.fired = true;
            }
            this.drawBeam();
          }
        }
      }
      class BlackHole {
        constructor(x, y, isTemporary = false) {
          this.x = x;
          this.y = y;
          this.radius = GAME_CONFIG.blackHoles.baseRadius;
          const difficultyLevel = Math.floor(
            score / GAME_CONFIG.difficulty.levelUpInterval
          );

          // Random variations for unpredictability
          const sizeVariation = 0.7 + Math.random() * 0.6; // 70%-130%
          const strengthVariation = 0.8 + Math.random() * 0.4; // 80%-120%

          this.gravityRadius =
            (GAME_CONFIG.blackHoles.baseGravityRadius +
              difficultyLevel *
                GAME_CONFIG.blackHoles.gravityRadiusIncreasePerLevel) *
            sizeVariation;
          this.strength =
            (GAME_CONFIG.blackHoles.baseStrength +
              difficultyLevel *
                GAME_CONFIG.blackHoles.strengthIncreasePerLevel) *
            strengthVariation;
          this.maxRadius =
            (GAME_CONFIG.blackHoles.baseMaxRadius +
              difficultyLevel * GAME_CONFIG.blackHoles.radiusIncreasePerLevel) *
            sizeVariation;
          this.growthRate =
            (GAME_CONFIG.blackHoles.baseGrowthRate +
              difficultyLevel *
                GAME_CONFIG.blackHoles.growthRateIncreasePerLevel) *
            (0.5 + Math.random());
          this.alpha = 0;
          this.isTemporary = isTemporary;
          this.life = GAME_CONFIG.blackHoles.temporaryLifetime;
          this.state = "growing"; // growing, fading
          this.particles = Array(50)
            .fill(null)
            .map(() => ({
              angle: Math.random() * Math.PI * 2,
              radius: this.radius + 5 + Math.random() * 20,
              speed: 0.01 + Math.random() * 0.02,
              size: Math.random() * 1.5,
            }));
        }
        draw() {
          ctx.save();
          ctx.globalAlpha = this.alpha;
          ctx.translate(this.x, this.y);
          this.particles.forEach((p) => {
            ctx.beginPath();
            ctx.arc(
              p.radius * Math.cos(p.angle),
              p.radius * Math.sin(p.angle),
              p.size,
              0,
              Math.PI * 2
            );
            ctx.fillStyle = `rgba(170, 102, 204, ${
              0.8 * (1 - p.radius / this.gravityRadius)
            })`;
            ctx.fill();
          });
          // Draw gravity field indicator
          ctx.beginPath();
          ctx.arc(0, 0, this.gravityRadius, 0, Math.PI * 2);
          ctx.strokeStyle = `rgba(170, 102, 204, ${0.1 * this.alpha})`;
          ctx.lineWidth = 2;
          ctx.setLineDash([10, 10]);
          ctx.stroke();
          ctx.setLineDash([]);

          // Black hole core
          ctx.beginPath();
          ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
          ctx.fillStyle = "#000";
          ctx.fill();
          ctx.restore();
        }
        update() {
          if (this.isTemporary) {
            this.life--;
            if (this.life <= 0) this.state = "fading";
          }
          if (this.state === "growing") {
            if (this.alpha < 1) this.alpha += 0.01;
            if (this.radius < this.maxRadius && !this.isTemporary) {
              this.radius += this.growthRate;
              this.gravityRadius += this.growthRate * 4;
            } else if (!this.isTemporary) {
              this.state = "fading";
            }
          } else {
            // fading
            this.alpha -= 0.01;
          }

          this.particles.forEach((p) => {
            p.angle += p.speed;
            if (p.radius > this.radius + 5) p.radius -= 0.1;
          });

          [player, ...asteroids, ...missiles, ...fragments].forEach((obj) => {
            if (!obj) return;
            const dist = Math.hypot(obj.x - this.x, obj.y - this.y);
            if (dist < this.gravityRadius) {
              const angle = Math.atan2(this.y - obj.y, this.x - obj.x);
              const falloff = 1 - dist / this.gravityRadius;

              // Stronger effect on player for dramatic gameplay
              let forceMultiplier =
                obj === player
                  ? GAME_CONFIG.blackHoles.playerForceMultiplier
                  : 1;

              // Distance-based intensity for realistic feel
              const force = falloff * this.strength * forceMultiplier;

              obj.velocity.x += Math.cos(angle) * force;
              obj.velocity.y += Math.sin(angle) * force;

              // Visual feedback for player when in gravity field
              if (
                obj === player &&
                dist <
                  this.gravityRadius * GAME_CONFIG.blackHoles.shakeThreshold
              ) {
                triggerScreenShake(GAME_CONFIG.blackHoles.shakeIntensity);
              }
            }
          });
          this.draw();
        }
      }
      class Missile {
        constructor() {
          // Diverse spawn patterns for missiles
          const spawnPattern = Math.random();
          if (spawnPattern < 0.4) {
            // Side spawn (40%)
            this.fromLeft = Math.random() > 0.5;
            this.x = this.fromLeft ? -20 : width + 20;
            this.y = Math.random() * height;
            this.angle = this.fromLeft ? 0 : Math.PI;
          } else if (spawnPattern < 0.7) {
            // Top/Bottom spawn (30%)
            this.fromTop = Math.random() > 0.5;
            this.x = Math.random() * width;
            this.y = this.fromTop ? -20 : height + 20;
            this.angle = this.fromTop ? Math.PI / 2 : -Math.PI / 2;
            this.fromLeft = false; // For trail purposes
          } else if (spawnPattern < 0.85) {
            // Corner spawn (15%)
            this.x = Math.random() < 0.5 ? -20 : width + 20;
            this.y = Math.random() < 0.5 ? -20 : height + 20;
            this.angle = Math.atan2(height / 2 - this.y, width / 2 - this.x);
            this.fromLeft = this.x < 0;
          } else {
            // Random edge spawn (15%)
            const edge = Math.floor(Math.random() * 4);
            switch (edge) {
              case 0: // Top
                this.x = Math.random() * width;
                this.y = -20;
                this.angle = Math.PI / 2;
                break;
              case 1: // Right
                this.x = width + 20;
                this.y = Math.random() * height;
                this.angle = Math.PI;
                break;
              case 2: // Bottom
                this.x = Math.random() * width;
                this.y = height + 20;
                this.angle = -Math.PI / 2;
                break;
              case 3: // Left
                this.x = -20;
                this.y = Math.random() * height;
                this.angle = 0;
                break;
            }
            this.fromLeft = this.x < width / 2;
          }
          this.radius = GAME_CONFIG.missiles.radius;
          const difficultyLevel = Math.floor(
            score / GAME_CONFIG.difficulty.levelUpInterval
          );
          this.speed =
            (GAME_CONFIG.missiles.baseSpeed +
              difficultyLevel * GAME_CONFIG.missiles.speedIncreasePerLevel) *
            globalSpeedMultiplier;
          this.turnSpeed =
            GAME_CONFIG.missiles.baseTurnSpeed +
            difficultyLevel * GAME_CONFIG.missiles.turnSpeedIncreasePerLevel;
          this.trail = [];
          this.lifeTimer = 0;
          this.hasSpedUp = false;
          this.isDead = false;
          this.velocity = { x: 0, y: 0 };
        }
        draw() {
          this.trail.forEach((p) => {
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(244, 143, 177, ${p.a})`;
            ctx.fill();
          });
          ctx.save();
          ctx.translate(this.x, this.y);
          ctx.rotate(this.angle + Math.PI / 2);
          ctx.beginPath();
          ctx.moveTo(0, -this.radius * 2);
          ctx.lineTo(this.radius, this.radius);
          ctx.lineTo(-this.radius, this.radius);
          ctx.closePath();
          ctx.fillStyle = "var(--missile-color)";
          ctx.shadowColor = "var(--missile-color)";
          ctx.shadowBlur = 10;
          ctx.fill();
          ctx.restore();
        }
        update() {
          this.lifeTimer++;
          if (
            !this.hasSpedUp &&
            this.lifeTimer > GAME_CONFIG.missiles.speedUpTime
          ) {
            this.speed *= GAME_CONFIG.missiles.speedUpMultiplier;
            this.turnSpeed *= GAME_CONFIG.missiles.turnSpeedUpMultiplier;
            this.hasSpedUp = true;
            playSound("missile"); // Play sound when speeding up
          }
          if (this.lifeTimer > GAME_CONFIG.missiles.lifetime) {
            this.explode();
            return;
          }

          const targetAngle = Math.atan2(player.y - this.y, player.x - this.x);
          let angleDiff = targetAngle - this.angle;
          while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
          while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
          this.angle += angleDiff * this.turnSpeed;
          this.velocity.x += Math.cos(this.angle) * this.speed;
          this.velocity.y += Math.sin(this.angle) * this.speed;
          this.x += this.velocity.x;
          this.y += this.velocity.y;
          this.velocity.x *= GAME_CONFIG.missiles.velocity.friction;
          this.velocity.y *= GAME_CONFIG.missiles.velocity.friction;

          this.trail.push({ x: this.x, y: this.y, r: this.radius / 2, a: 1 });
          this.trail.forEach((p) => {
            p.a -= 0.05;
            p.r -= 0.05;
          });
          this.trail = this.trail.filter((p) => p.a > 0);
          this.draw();
        }
        explode(isImpact = false) {
          this.isDead = true;
          const fragmentCount = isImpact
            ? GAME_CONFIG.missiles.fragmentCountOnImpact
            : GAME_CONFIG.missiles.fragmentCount;
          for (let i = 0; i < fragmentCount; i++) {
            const angle = (i / fragmentCount) * Math.PI * 2;
            const fragmentSpeed = 3 + Math.random() * 4;
            const vel = {
              x: Math.cos(angle) * fragmentSpeed,
              y: Math.sin(angle) * fragmentSpeed,
            };
            fragments.push(new Fragment(this.x, this.y, vel));
          }
        }
      }
      class LaserMine {
        constructor(x, y) {
          this.x = x;
          this.y = y;
          this.radius = GAME_CONFIG.laserMines.radius;
          this.timer = 0;
          this.maxTime = GAME_CONFIG.laserMines.chargeTime;
          this.fireDuration = GAME_CONFIG.laserMines.fireDuration;
          this.state = "charging";
          this.alpha = 0;
          this.pattern =
            GAME_CONFIG.laserMines.patterns[
              Math.floor(Math.random() * GAME_CONFIG.laserMines.patterns.length)
            ];
          this.warningShown = false;
        }

        getFireAngles() {
          switch (this.pattern) {
            case "cross":
              return [0, Math.PI / 2, Math.PI, (3 * Math.PI) / 2];
            case "diagonal":
              return [
                Math.PI / 4,
                (3 * Math.PI) / 4,
                (5 * Math.PI) / 4,
                (7 * Math.PI) / 4,
              ];
            case "star":
              const angles = [];
              for (let i = 0; i < 8; i++) {
                angles.push((i * Math.PI) / 4);
              }
              return angles;
            case "random":
              const randomAngles = [];
              const count = Math.floor(Math.random() * 3);
              for (let i = 0; i < count; i++) {
                randomAngles.push(Math.random() * Math.PI * 2);
              }
              return randomAngles;
            default:
              return [0, Math.PI / 2, Math.PI, (3 * Math.PI) / 2];
          }
        }

        drawWarningBeams() {
          if (this.state !== "charging" || this.timer < 30) return;

          ctx.save();
          ctx.globalAlpha =
            GAME_CONFIG.laserMines.warningOpacity * Math.sin(this.timer * 0.03);
          ctx.strokeStyle = "#ffff00";
          ctx.lineWidth = 2;
          ctx.setLineDash([5, 5]);

          const angles = this.getFireAngles();
          angles.forEach((angle) => {
            const endX = this.x + Math.cos(angle) * 1000;
            const endY = this.y + Math.sin(angle) * 1000;

            ctx.beginPath();
            ctx.moveTo(this.x, this.y);
            ctx.lineTo(endX, endY);
            ctx.stroke();
          });

          ctx.setLineDash([]);
          ctx.restore();
        }

        draw() {
          if (this.state === "fading") return;

          this.drawWarningBeams();

          ctx.save();
          ctx.globalAlpha = this.alpha;
          if (this.state === "charging") {
            const pulse = Math.abs(Math.sin(this.timer * 0.1)) * 5;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius + pulse, 0, Math.PI * 2);
            ctx.fillStyle = "#ff4444";
            ctx.shadowColor = "#ff4444";
            ctx.shadowBlur = 15;
            ctx.fill();

            // Pattern indicator
            ctx.globalAlpha = 0.6;
            ctx.fillStyle = "#ffff00";
            ctx.font = "12px Exo 2";
            ctx.textAlign = "center";
            ctx.fillText(
              this.pattern.toUpperCase(),
              this.x,
              this.y - this.radius - 10
            );
          } else if (this.state === "firing") {
            const angles = this.getFireAngles();
            ctx.fillStyle = "#fff";
            ctx.shadowColor = "#ff4444";
            ctx.shadowBlur = 20;

            angles.forEach((angle) => {
              const length = 1500;
              const beamWidth = GAME_CONFIG.laserMines.beamWidth;
              const endX = this.x + Math.cos(angle) * length;
              const endY = this.y + Math.sin(angle) * length;

              ctx.save();
              ctx.translate(this.x, this.y);
              ctx.rotate(angle);
              ctx.fillRect(0, -beamWidth / 2, length, beamWidth);
              ctx.restore();
            });
          }
          ctx.restore();
        }

        update() {
          if (this.alpha < 1 && this.state !== "fading") this.alpha += 0.02;
          this.timer++;

          if (
            this.state === "charging" &&
            this.timer === 60 &&
            !this.warningShown
          ) {
            playSound("laserMine");
            this.warningShown = true;
          }

          if (this.state === "charging" && this.timer > this.maxTime) {
            this.state = "firing";
            this.timer = 0;
            triggerScreenShake(GAME_CONFIG.visual.screenShake.mineIntensity);
          }
          if (this.state === "firing" && this.timer > this.fireDuration) {
            this.state = "fading";
          }
          this.draw();
        }
      }
      class CrystalCluster {
        constructor(x, y) {
          this.x = x;
          this.y = y;
          this.radius = 15;
          this.timer = 0;
          this.maxChargeTime = 180; // 3 seconds
          this.state = "charging"; // charging, discharging
          this.dischargeRadius = 0;
          this.dischargeSpeed = 5;
          this.alpha = 0;
          this.crystals = Array(5)
            .fill(null)
            .map(() => ({
              angle: Math.random() * Math.PI * 2,
              dist: this.radius + Math.random() * 10,
              size: 3 + Math.random() * 4,
            }));
        }
        draw() {
          if (this.alpha <= 0 && this.state !== "charging") return;
          ctx.save();
          ctx.globalAlpha = this.alpha;
          ctx.translate(this.x, this.y);

          // Draw orbiting crystals
          this.crystals.forEach((c) => {
            ctx.save();
            ctx.rotate(c.angle);
            ctx.beginPath();
            ctx.rect(c.dist, -c.size / 2, c.size * 1.5, c.size);
            ctx.fillStyle = "var(--crystal-color)";
            ctx.shadowColor = "var(--crystal-color)";
            ctx.shadowBlur = 10;
            ctx.fill();
            ctx.restore();
          });

          // Draw central core
          ctx.beginPath();
          ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
          ctx.fillStyle = "white";
          ctx.shadowColor = "var(--crystal-color)";
          ctx.shadowBlur = 20;
          ctx.fill();

          if (this.state === "charging") {
            const chargeAuraRadius =
              this.radius + (this.timer / this.maxChargeTime) * 30;
            ctx.beginPath();
            ctx.arc(0, 0, chargeAuraRadius, 0, Math.PI * 2);
            ctx.strokeStyle = `rgba(64, 196, 255, ${
              0.5 * (this.timer / this.maxChargeTime)
            })`;
            ctx.lineWidth = 4;
            ctx.stroke();
          } else if (this.state === "discharging") {
            ctx.beginPath();
            ctx.arc(0, 0, this.dischargeRadius, 0, Math.PI * 2);
            ctx.strokeStyle = `rgba(64, 196, 255, ${
              1 - this.dischargeRadius / (width / 2)
            })`;
            ctx.lineWidth = 10;
            ctx.stroke();
          }
          ctx.restore();
        }
        update() {
          if (this.alpha < 1 && this.state === "charging") this.alpha += 0.02;
          this.crystals.forEach((c) => (c.angle += 0.01));
          this.timer++;

          if (this.state === "charging" && this.timer > this.maxChargeTime) {
            this.state = "discharging";
            triggerScreenShake(0.3);
          }
          if (this.state === "discharging") {
            this.dischargeRadius += this.dischargeSpeed;
            this.alpha -= 0.01;
          }
          this.draw();
        }
      }

      // --- Game Logic ---
      function createNebula() {
        const x = Math.random() * width;
        const y = Math.random() * height;
        const r =
          GAME_CONFIG.visual.nebula.minRadius +
          Math.random() *
            (GAME_CONFIG.visual.nebula.maxRadius -
              GAME_CONFIG.visual.nebula.minRadius);
        const grad = ctx.createRadialGradient(x, y, 10, x, y, r);
        const color = [
          `rgba(0, 255, 255, ${GAME_CONFIG.visual.nebula.opacity})`,
          `rgba(170, 102, 204, ${GAME_CONFIG.visual.nebula.opacity})`,
          `rgba(51, 181, 229, ${GAME_CONFIG.visual.nebula.opacity})`,
        ][~~(Math.random() * 3)];
        grad.addColorStop(
          0,
          color.replace(
            `${GAME_CONFIG.visual.nebula.opacity})`,
            `${GAME_CONFIG.visual.nebula.opacity * 2})`
          )
        );
        grad.addColorStop(1, color);
        return grad;
      }

      function init() {
        width = canvas.width = window.innerWidth;
        height = canvas.height = window.innerHeight;
        mouse = { x: width / 2, y: height * 0.8 };
        prevMouse = { ...mouse };
        isGameRunning = true;
        score = 0;
        gameStartTime = Date.now();
        survivalTime = 0;
        spawnInterval = GAME_CONFIG.difficulty.baseSpawnInterval;
        globalSpeedMultiplier = GAME_CONFIG.difficulty.baseSpeed;
        nextEventScore = GAME_CONFIG.events.interval;
        eventActive = { type: null, endTime: 0 };
        timers = {
          asteroid: 0,
          difficulty: 0,
          laser: 0,
          blackHole: 0,
          missile: 0,
          mine: 0,
          crystal: 0,
        };
        player = new Player(
          width / 2,
          height * 0.8,
          GAME_CONFIG.player.radius,
          "var(--primary-color)"
        );
        stars = [];
        asteroids = [];
        particles = [];
        lasers = [];
        blackHoles = [];
        missiles = [];
        laserMines = [];
        crystalClusters = [];
        fragments = [];
        warnings = [];
        for (let i = 0; i < GAME_CONFIG.visual.stars.layers; i++) {
          const layer = (i + 1) / GAME_CONFIG.visual.stars.layers;
          for (let j = 0; j < GAME_CONFIG.visual.stars.starsPerLayer; j++)
            stars.push(
              new Star(
                Math.random() * width,
                Math.random() * height,
                Math.random() * GAME_CONFIG.visual.stars.maxRadius * layer,
                layer
              )
            );
        }
        nebulae = Array(GAME_CONFIG.visual.nebula.count)
          .fill(null)
          .map(() => createNebula());
        highScore =
          localStorage.getItem(GAME_CONFIG.advanced.localStorageKey) || 0;
        uiElements.highscoreDisplay.innerText = `High Score: ${highScore}`;
      }

      function animate() {
        animationFrameId = requestAnimationFrame(animate);
        ctx.fillStyle = "#050510";
        ctx.fillRect(0, 0, width, height);
        nebulae.forEach((n) => {
          ctx.fillStyle = n;
          ctx.fillRect(0, 0, width, height);
        });

        stars.sort((a, b) => a.layer - b.layer).forEach((s) => s.update());
        if (!isGameRunning) {
          particles.forEach((p, i) =>
            p.alpha <= 0 ? particles.splice(i, 1) : p.update()
          );
          return;
        }

        timers.difficulty++;

        // Update survival time
        survivalTime = Math.floor((Date.now() - gameStartTime) / 1000);
        const minutes = Math.floor(survivalTime / 60);
        const seconds = survivalTime % 60;
        uiElements.survivalDisplay.innerText = `Time: ${minutes}:${seconds
          .toString()
          .padStart(2, "0")}`;

        const distMoved = Math.hypot(
          mouse.x - prevMouse.x,
          mouse.y - prevMouse.y
        );
        // Dynamic movement threshold - giảm dần theo level
        const currentLevel =
          Math.floor(score / GAME_CONFIG.difficulty.levelUpInterval) + 1;
        const dynamicThreshold = Math.max(
          GAME_CONFIG.scoring.minMovementThreshold,
          GAME_CONFIG.scoring.baseMovementThreshold *
            Math.pow(GAME_CONFIG.scoring.thresholdDecreaseRate, currentLevel)
        );

        // Chỉ tăng điểm khi di chuyển đủ xa (threshold giảm dần theo level)
        if (distMoved >= dynamicThreshold) {
          score += distMoved * GAME_CONFIG.scoring.movementMultiplier;
        }
        prevMouse = { ...mouse };
        uiElements.scoreDisplay.innerText = `Score: ${~~score}`;

        [
          particles,
          lasers,
          blackHoles,
          missiles,
          laserMines,
          asteroids,
          crystalClusters,
          fragments,
          warnings,
        ].forEach((arr) =>
          arr.forEach((item) => (item.update ? item.update() : undefined))
        );
        player.update(); // Update player last to draw over everything

        // --- Filter dead entities ---
        missiles = missiles.filter((m) => !m.isDead);
        fragments = fragments.filter((f) => f.life > 0 && f.y < height + 50);
        asteroids = asteroids.filter(
          (a) => a.x > -50 && a.x < width + 50 && a.y > -50 && a.y < height + 50
        );
        blackHoles = blackHoles.filter((bh) => bh.alpha > 0);
        crystalClusters = crystalClusters.filter((cc) => cc.alpha > 0);
        warnings = warnings.filter((w) => w.timer < w.duration);

        // --- Event System ---
        if (score >= nextEventScore) {
          triggerRandomEvent();
          // Random event timing for unpredictability
          const eventVariation = 0.7 + Math.random() * 0.6; // 70%-130% of base interval
          nextEventScore += GAME_CONFIG.events.interval * eventVariation;
        }
        if (eventActive.type && timers.difficulty > eventActive.endTime) {
          if (eventActive.type === "speedZone")
            globalSpeedMultiplier /=
              GAME_CONFIG.events.speedZone.speedMultiplier;
          if (eventActive.type === "timeWarp")
            globalSpeedMultiplier /=
              GAME_CONFIG.events.timeWarp.speedMultiplier;
          eventActive.type = null;
        }

        let currentSpawnInterval =
          eventActive.type === "denseField" &&
          timers.difficulty < eventActive.endTime
            ? GAME_CONFIG.events.denseField.spawnInterval
            : spawnInterval;

        // --- Spawning Logic ---
        timers.asteroid++;
        if (timers.asteroid % currentSpawnInterval === 0) {
          const difficultyLevel = Math.floor(
            score / GAME_CONFIG.difficulty.levelUpInterval
          );
          const radius =
            eventActive.type === "denseField"
              ? GAME_CONFIG.asteroids.minRadius +
                Math.random() *
                  (GAME_CONFIG.asteroids.maxRadius -
                    GAME_CONFIG.asteroids.minRadius) *
                  0.6
              : GAME_CONFIG.asteroids.minRadius +
                Math.random() *
                  (GAME_CONFIG.asteroids.maxRadius -
                    GAME_CONFIG.asteroids.minRadius);
          const asteroidSpeed =
            (GAME_CONFIG.asteroids.baseSpeed +
              Math.random() * GAME_CONFIG.asteroids.speedVariation +
              difficultyLevel * GAME_CONFIG.asteroids.speedIncreasePerLevel) *
            globalSpeedMultiplier;
          // Predictable asteroid patterns - mostly from top
          let spawnX, spawnY, velocityX, velocityY;
          const spawnPattern = Math.random();

          if (spawnPattern < 0.7) {
            // Top spawn straight down (70%)
            spawnX = Math.random() * width;
            spawnY = -30;
            velocityX = 0;
            velocityY = asteroidSpeed;
          } else if (spawnPattern < 0.9) {
            // Top spawn with slight angle (20%)
            spawnX = Math.random() * width;
            spawnY = -30;
            velocityX = (Math.random() - 0.5) * asteroidSpeed * 0.3; // Very slight angle
            velocityY = asteroidSpeed;
          } else {
            // Diagonal from corners (10%)
            const fromLeft = Math.random() < 0.5;
            spawnX = fromLeft ? -30 : width + 30;
            spawnY = -30;
            velocityX = fromLeft ? asteroidSpeed * 0.4 : -asteroidSpeed * 0.4;
            velocityY = asteroidSpeed * 0.8;
          }

          asteroids.push(
            new Asteroid(
              spawnX,
              spawnY,
              radius,
              GAME_CONFIG.asteroids.colors[
                ~~(Math.random() * GAME_CONFIG.asteroids.colors.length)
              ],
              { x: velocityX, y: velocityY }
            )
          );
        }
        if (score > GAME_CONFIG.blackHoles.spawnScore) {
          timers.blackHole++;
          if (timers.blackHole % GAME_CONFIG.blackHoles.spawnInterval === 0) {
            const bhX = Math.random() * width * 0.8 + width * 0.1;
            const bhY = Math.random() * height * 0.8;
            // Show warning first
            warnings.push(
              new Warning(
                bhX,
                bhY,
                "blackhole",
                GAME_CONFIG.blackHoles.warningDuration
              )
            );
            playSound("warning");
            // Create black hole after warning period
            setTimeout(() => {
              if (isGameRunning) {
                blackHoles.push(new BlackHole(bhX, bhY));
                playSound("blackhole");
              }
            }, GAME_CONFIG.blackHoles.warningDelay);
          }
        }
        if (score > GAME_CONFIG.missiles.spawnScore) {
          timers.missile++;
          if (timers.missile % GAME_CONFIG.missiles.spawnInterval === 0) {
            // Show warning at edges where missile will spawn
            const fromLeft = Math.random() > 0.5;
            const warningX = fromLeft ? 50 : width - 50;
            const warningY = Math.random() * height;
            warnings.push(
              new Warning(
                warningX,
                warningY,
                "missile",
                GAME_CONFIG.missiles.warningDuration
              )
            );
            playSound("warning");
            // Create missile after warning period
            setTimeout(() => {
              if (isGameRunning) {
                missiles.push(new Missile());
              }
            }, GAME_CONFIG.missiles.warningDelay);
          }
        }
        if (score > GAME_CONFIG.lasers.spawnScore) {
          timers.laser++;
          const difficultyLevel = Math.floor(
            score / GAME_CONFIG.difficulty.levelUpInterval
          );
          const laserInterval = Math.max(
            GAME_CONFIG.lasers.minInterval,
            GAME_CONFIG.lasers.baseInterval -
              difficultyLevel * GAME_CONFIG.lasers.intervalDecreasePerLevel
          );
          if (timers.laser % laserInterval === 0) {
            // Multiple lasers for higher intensity
            const laserCount = Math.min(
              GAME_CONFIG.lasers.maxConcurrent,
              1 +
                Math.floor(difficultyLevel / GAME_CONFIG.lasers.lasersPerLevel)
            );

            for (let i = 0; i < laserCount; i++) {
              setTimeout(() => {
                if (isGameRunning) {
                  const targetChance = Math.min(
                    GAME_CONFIG.lasers.maxTargetChance,
                    GAME_CONFIG.lasers.baseTargetChance +
                      difficultyLevel *
                        GAME_CONFIG.lasers.targetChanceIncreasePerLevel
                  );
                  const shouldTarget = Math.random() < targetChance;
                  lasers.push(new Laser(shouldTarget));
                  if (shouldTarget) {
                    playSound("warning");
                  }
                }
              }, i * GAME_CONFIG.lasers.staggerDelay);
            }
          }
        }
        if (score > GAME_CONFIG.laserMines.spawnScore) {
          timers.mine++;
          if (timers.mine % GAME_CONFIG.laserMines.spawnInterval === 0)
            laserMines.push(
              new LaserMine(
                Math.random() * width * 0.8 + width * 0.1,
                Math.random() * height * 0.6
              )
            );
        }
        if (score > 9000) {
          timers.crystal++;
          if (timers.crystal % 800 === 0)
            crystalClusters.push(
              new CrystalCluster(
                Math.random() * width,
                Math.random() * height * 0.7
              )
            );
        }

        // --- Collision Detection ---
        // Player vs Obstacles
        for (const ast of asteroids) {
          if (
            Math.hypot(player.x - ast.x, player.y - ast.y) -
              ast.radius -
              player.radius <
            1
          ) {
            endGame("asteroid collision");
            return;
          }
        }
        for (const m of missiles) {
          if (
            Math.hypot(player.x - m.x, player.y - m.y) -
              m.radius -
              player.radius <
            1
          ) {
            endGame("missile collision");
            return;
          }
        }

        // Lasers vs Player
        for (const laser of lasers) {
          if (laser.timer > laser.maxTime + GAME_CONFIG.lasers.beamDuration)
            continue;
          if (laser.fired) {
            const dx = Math.cos(laser.angle);
            const dy = Math.sin(laser.angle);
            const dist = Math.abs(
              dy * (player.x - laser.x) - dx * (player.y - laser.y)
            );
            if (dist < player.radius + GAME_CONFIG.lasers.playerHitRadius) {
              endGame("laser collision");
              return;
            }
          }
        }
        lasers = lasers.filter(
          (l) => l.timer < l.maxTime + GAME_CONFIG.lasers.beamDuration
        );

        // Mines & Crystals vs Player
        for (let i = laserMines.length - 1; i >= 0; i--) {
          const mine = laserMines[i];
          if (mine.state === "fading") {
            laserMines.splice(i, 1);
          } else if (mine.state === "firing") {
            const angles = mine.getFireAngles();
            let hitDetected = false;

            for (const angle of angles) {
              const dx = Math.cos(angle);
              const dy = Math.sin(angle);
              const dist = Math.abs(
                dy * (player.x - mine.x) - dx * (player.y - mine.y)
              );
              if (dist < player.radius + GAME_CONFIG.laserMines.beamWidth / 2) {
                // Check if player is in beam range
                const dotProduct =
                  (player.x - mine.x) * dx + (player.y - mine.y) * dy;
                if (dotProduct > 0) {
                  // Player is in front of beam
                  hitDetected = true;
                  break;
                }
              }
            }

            if (hitDetected) {
              endGame("laser mine collision");
              return;
            }
          }
        }
        for (const cc of crystalClusters) {
          if (cc.state === "discharging") {
            const dist = Math.hypot(player.x - cc.x, player.y - cc.y);
            if (Math.abs(dist - cc.dischargeRadius) < player.radius + 5) {
              endGame("crystal cluster collision");
              return;
            }
          }
        }

        // Fragment vs Player collisions (lethal missile fragments)
        for (let i = fragments.length - 1; i >= 0; i--) {
          const fragment = fragments[i];
          if (
            fragment.lethal &&
            Math.hypot(player.x - fragment.x, player.y - fragment.y) <
              player.radius + fragment.radius
          ) {
            endGame("missile fragment collision");
            return;
          }
        }

        // Inter-object collisions
        // Fragment vs Asteroid collisions
        for (let i = fragments.length - 1; i >= 0; i--) {
          for (let j = asteroids.length - 1; j >= 0; j--) {
            const f = fragments[i];
            const a = asteroids[j];
            if (
              f &&
              a &&
              Math.hypot(f.x - a.x, f.y - a.y) < f.radius + a.radius
            ) {
              // Create explosion particles
              for (
                let k = 0;
                k < GAME_CONFIG.fragments.explosionParticles;
                k++
              ) {
                particles.push(
                  new Particle(a.x, a.y, Math.random() * 2 + 1, a.color, {
                    x:
                      (Math.random() - 0.5) *
                      GAME_CONFIG.visual.particles.explosionSpeed,
                    y:
                      (Math.random() - 0.5) *
                      GAME_CONFIG.visual.particles.explosionSpeed,
                  })
                );
              }
              playSound("collision");
              playSound("score");
              score += GAME_CONFIG.fragments.scoreBonus;
              fragments.splice(i, 1);
              asteroids.splice(j, 1);
              break;
            }
          }
        }

        // Missile vs Asteroid collisions - tạo missile fragments
        for (let i = missiles.length - 1; i >= 0; i--) {
          for (let j = asteroids.length - 1; j >= 0; j--) {
            const m = missiles[i];
            const a = asteroids[j];
            if (
              m &&
              a &&
              Math.hypot(m.x - a.x, m.y - a.y) < m.radius + a.radius
            ) {
              // Tạo missile fragments khi tên lửa va chạm thiên thạch
              const fragmentCount = GAME_CONFIG.missiles.fragmentCountOnImpact;
              for (let k = 0; k < fragmentCount; k++) {
                const angle =
                  (Math.PI * 2 * k) / fragmentCount + Math.random() * 0.5;
                const speed =
                  GAME_CONFIG.fragments.missileFragments.speed *
                  (0.5 + Math.random() * 0.5);
                const velocity = {
                  x: Math.cos(angle) * speed,
                  y: Math.sin(angle) * speed,
                };
                fragments.push(new MissileFragment(m.x, m.y, velocity));
              }

              playSound("fragmentHit", 0.5);
              m.explode(true);
              asteroids.splice(j, 1);
              break;
            }
          }
        }
        for (let i = blackHoles.length - 1; i >= 0; i--) {
          const bh = blackHoles[i];
          if (Math.hypot(player.x - bh.x, player.y - bh.y) < bh.radius) {
            endGame("black hole collision");
            return;
          }
          for (let j = asteroids.length - 1; j >= 0; j--) {
            if (
              Math.hypot(asteroids[j].x - bh.x, asteroids[j].y - bh.y) <
              bh.radius
            )
              asteroids.splice(j, 1);
          }
          for (let j = missiles.length - 1; j >= 0; j--) {
            if (
              Math.hypot(missiles[j].x - bh.x, missiles[j].y - bh.y) < bh.radius
            )
              missiles[j].isDead = true;
          }
        }

        // Difficulty Progression
        const difficultyLevel = Math.floor(
          score / GAME_CONFIG.difficulty.levelUpInterval
        );
        const previousDifficultyLevel = Math.floor(
          (score - distMoved * GAME_CONFIG.scoring.movementMultiplier) /
            GAME_CONFIG.difficulty.levelUpInterval
        );

        if (difficultyLevel > previousDifficultyLevel && difficultyLevel > 0) {
          // Show difficulty increase message
          showEventText(`Level ${difficultyLevel}!`);
          playSound("powerup");

          // Smoother progression for flow state
          globalSpeedMultiplier += GAME_CONFIG.difficulty.speedIncreaseStep;
          if (spawnInterval > GAME_CONFIG.difficulty.minSpawnInterval) {
            spawnInterval -= GAME_CONFIG.difficulty.spawnDecreaseStep;
          }
        }

        // Micro-progression for engagement
        if (
          timers.difficulty % GAME_CONFIG.difficulty.microProgressInterval ===
          0
        ) {
          if (spawnInterval > GAME_CONFIG.difficulty.minSpawnInterval + 5)
            spawnInterval -= 2;
          globalSpeedMultiplier += GAME_CONFIG.difficulty.microSpeedIncrease;
        }
      }

      function showEventText(text) {
        uiElements.eventText.innerText = text;
        uiElements.eventText.style.fontSize = GAME_CONFIG.ui.eventText.fontSize;
        uiElements.eventText.style.opacity = "1";
        setTimeout(() => {
          uiElements.eventText.style.opacity = "0";
        }, GAME_CONFIG.ui.eventText.duration);
      }

      function triggerRandomEvent() {
        let eventTypes = [
          "denseField",
          "speedZone",
          "instantMissiles",
          "laserSwarm",
          "gravitationalAnomaly",
          "asteroidRain",
          "timeWarp",
          "missileBarrage",
          "laserGrid",
          "blackHoleChain",
          // New events
          "wormholePortal",
          "shieldGenerator",
          "freezeZone",
          "magneticStorm",
          "asteroidBelt",
          "laserTurrets",
        ];
        // Filter events based on unlock thresholds
        eventTypes = eventTypes.filter((eventType) => {
          const threshold = GAME_CONFIG.events.unlockThresholds[eventType];
          return !threshold || score >= threshold;
        });
        const randomEventType =
          eventTypes[Math.floor(Math.random() * eventTypes.length)];

        eventActive.endTime = timers.difficulty + GAME_CONFIG.events.duration;

        switch (randomEventType) {
          case "denseField":
            eventActive.type = "denseField";
            showEventText("Asteroid Storm!");
            break;
          case "speedZone":
            eventActive.type = "speedZone";
            globalSpeedMultiplier *=
              GAME_CONFIG.events.speedZone.speedMultiplier;
            showEventText("Difficulty Spike!");
            break;
          case "instantMissiles":
            if (score > 3000) {
              missiles.push(new Missile());
              missiles.push(new Missile());
              showEventText("Surprise Missiles!");
            } else {
              eventActive.type = "denseField";
              showEventText("Asteroid Storm!");
            }
            break;
          case "laserSwarm":
            for (let i = 0; i < GAME_CONFIG.events.laserSwarm.laserCount; i++) {
              setTimeout(() => {
                if (isGameRunning) {
                  const shouldTarget =
                    Math.random() < GAME_CONFIG.events.laserSwarm.targetChance;
                  lasers.push(new Laser(shouldTarget));
                  if (shouldTarget) playSound("warning");
                }
              }, i * GAME_CONFIG.events.laserSwarm.delay);
            }
            showEventText("Laser Swarm!");
            break;
          case "gravitationalAnomaly":
            for (
              let i = 0;
              i < GAME_CONFIG.events.gravitationalAnomaly.blackHoleCount;
              i++
            )
              blackHoles.push(
                new BlackHole(
                  Math.random() * width,
                  Math.random() * height,
                  true
                )
              );
            showEventText("Gravitational Anomaly!");
            break;
          case "asteroidRain":
            eventActive.type = "asteroidRain";
            showEventText("Asteroid Rain!");
            for (let i = 0; i < GAME_CONFIG.events.asteroidRain.count; i++) {
              setTimeout(() => {
                if (isGameRunning) {
                  asteroids.push(
                    new Asteroid(
                      Math.random() * width,
                      -30,
                      GAME_CONFIG.events.asteroidRain.minRadius +
                        Math.random() *
                          (GAME_CONFIG.events.asteroidRain.maxRadius -
                            GAME_CONFIG.events.asteroidRain.minRadius),
                      "#ff4444",
                      {
                        x: 0,
                        y:
                          (GAME_CONFIG.events.asteroidRain.speedMultiplier +
                            Math.random() *
                              GAME_CONFIG.events.asteroidRain.speedVariation) *
                          globalSpeedMultiplier,
                      }
                    )
                  );
                }
              }, i * GAME_CONFIG.events.asteroidRain.delay);
            }
            break;
          case "timeWarp":
            eventActive.type = "timeWarp";
            globalSpeedMultiplier *=
              GAME_CONFIG.events.timeWarp.speedMultiplier;
            showEventText("Time Warp!");
            break;
          case "missileBarrage":
            for (let i = 0; i < GAME_CONFIG.events.missileBarrage.count; i++) {
              setTimeout(() => {
                if (isGameRunning) {
                  missiles.push(new Missile());
                }
              }, i * GAME_CONFIG.events.missileBarrage.delay);
            }
            showEventText("Missile Barrage!");
            break;
          case "laserGrid":
            for (let i = 0; i < GAME_CONFIG.events.laserGrid.gridSize; i++) {
              setTimeout(() => {
                if (isGameRunning) {
                  // Create a grid pattern of lasers
                  lasers.push(new Laser(false));
                  lasers.push(new Laser(true));
                  if (i % 2 === 0) {
                    lasers.push(new Laser(Math.random() < 0.5));
                  }
                }
              }, i * GAME_CONFIG.events.laserGrid.delay);
            }
            showEventText("Laser Grid!");
            break;
          case "blackHoleChain":
            for (let i = 0; i < GAME_CONFIG.events.blackHoleChain.count; i++) {
              setTimeout(() => {
                if (isGameRunning) {
                  const x = Math.random() * width;
                  const y = Math.random() * height * 0.7;
                  warnings.push(
                    new Warning(
                      x,
                      y,
                      "blackhole",
                      GAME_CONFIG.blackHoles.warningDuration
                    )
                  );
                  setTimeout(() => {
                    if (isGameRunning) {
                      blackHoles.push(new BlackHole(x, y, true));
                      playSound("blackhole");
                    }
                  }, GAME_CONFIG.events.blackHoleChain.warningDelay);
                }
              }, i * GAME_CONFIG.events.blackHoleChain.delay);
            }
            showEventText("Black Hole Chain!");
            break;

          case "wormholePortal":
            eventActive.type = "wormholePortal";
            showEventText("Wormhole Portal!");
            for (let i = 0; i < GAME_CONFIG.events.wormholePortal.count; i++) {
              // Create paired wormholes
              const x1 = Math.random() * width * 0.8 + width * 0.1;
              const y1 = Math.random() * height * 0.6 + height * 0.2;
              const x2 = Math.random() * width * 0.8 + width * 0.1;
              const y2 = Math.random() * height * 0.6 + height * 0.2;
              // Implementation would need new Wormhole class
            }
            playSound("wormhole");
            break;

          case "shieldGenerator":
            eventActive.type = "shieldGenerator";
            showEventText("Shield Generators!");
            for (let i = 0; i < GAME_CONFIG.events.shieldGenerator.count; i++) {
              // Implementation would need new ShieldGenerator class
            }
            playSound("shield");
            break;

          case "freezeZone":
            eventActive.type = "freezeZone";
            globalSpeedMultiplier *= 0.3; // Slow everything down
            showEventText("Freeze Zone!");
            playSound("freeze");
            break;

          case "magneticStorm":
            eventActive.type = "magneticStorm";
            showEventText("Magnetic Storm!");
            // Implementation would affect player movement
            break;

          case "asteroidBelt":
            eventActive.type = "asteroidBelt";
            showEventText("Asteroid Belt!");
            for (let i = 0; i < GAME_CONFIG.events.asteroidBelt.count; i++) {
              const angle =
                (i / GAME_CONFIG.events.asteroidBelt.count) * Math.PI * 2;
              const x =
                width / 2 +
                Math.cos(angle) * GAME_CONFIG.events.asteroidBelt.beltRadius;
              const y =
                height / 2 +
                Math.sin(angle) * GAME_CONFIG.events.asteroidBelt.beltRadius;
              asteroids.push(
                new Asteroid(x, y, 15 + Math.random() * 10, "#ffbb33", {
                  x:
                    -Math.sin(angle) *
                    GAME_CONFIG.events.asteroidBelt.asteroidSpeed,
                  y:
                    Math.cos(angle) *
                    GAME_CONFIG.events.asteroidBelt.asteroidSpeed,
                })
              );
            }
            break;

          case "laserTurrets":
            eventActive.type = "laserTurrets";
            showEventText("Laser Turrets!");
            for (let i = 0; i < GAME_CONFIG.events.laserTurrets.count; i++) {
              // Implementation would need new LaserTurret class
            }
            break;
        }
      }

      function triggerScreenShake(intensity) {
        canvas.classList.add("shake");
        setTimeout(
          () => canvas.classList.remove("shake"),
          GAME_CONFIG.visual.screenShake.duration * 1000
        );
      }
      function startGame() {
        init();
        animate();
        playSound("backgroundMusic");
        uiElements.startScreen.style.display = "none";
        uiElements.gameOverScreen.style.display = "none";
        uiElements.scoreContainer.style.opacity = "1";
      }
      function endGame(reason = "unknown") {
        if (!isGameRunning) return;
        console.log(`Game Over! Reason: ${reason}`);
        isGameRunning = false;
        stopBackgroundMusic();
        playSound("explosion");
        cancelAnimationFrame(animationFrameId);
        triggerScreenShake(GAME_CONFIG.visual.screenShake.explosionIntensity);
        for (
          let i = 0;
          i < GAME_CONFIG.visual.particles.explosionCount * 8;
          i++
        )
          particles.push(
            new Particle(player.x, player.y, Math.random() * 3, "#ff4444", {
              x:
                (Math.random() - 0.5) *
                GAME_CONFIG.visual.particles.explosionSpeed *
                1.7,
              y:
                (Math.random() - 0.5) *
                GAME_CONFIG.visual.particles.explosionSpeed *
                1.7,
            })
          );
        score = ~~score;
        if (score > highScore) {
          highScore = score;
          localStorage.setItem(GAME_CONFIG.advanced.localStorageKey, highScore);
          uiElements.newHighscoreMsg.style.display = "block";
        } else {
          uiElements.newHighscoreMsg.style.display = "none";
        }
        setTimeout(() => {
          const minutes = Math.floor(survivalTime / 60);
          const seconds = survivalTime % 60;
          uiElements.finalScoreEl.innerText = `Your Score: ${score}`;
          uiElements.finalTimeEl.innerText = `Survival Time: ${minutes}:${seconds
            .toString()
            .padStart(2, "0")}`;
          uiElements.gameOverScreen.style.display = "flex";
          uiElements.scoreContainer.style.opacity = "0";
        }, 1000);
      }

      // --- Event Listeners ---
      startButton.addEventListener("click", () => {
        playSound("buttonHover");
        startGame();
      });
      restartButton.addEventListener("click", () => {
        playSound("buttonHover");
        startGame();
      });

      // Button hover sound effects
      startButton.addEventListener("mouseenter", () =>
        playSound("buttonHover")
      );
      restartButton.addEventListener("mouseenter", () =>
        playSound("buttonHover")
      );

      window.addEventListener("mousemove", (e) => {
        mouse.x = e.clientX;
        mouse.y = e.clientY;
      });
      window.addEventListener(
        "touchmove",
        (e) => {
          if (e.touches.length > 0) {
            e.preventDefault();
            mouse.x = e.touches[0].clientX;
            mouse.y = e.touches[0].clientY;
          }
        },
        { passive: false }
      );
      window.addEventListener("resize", () => {
        if (!isGameRunning) return;
        width = canvas.width = window.innerWidth;
        height = canvas.height = window.innerHeight;
        nebulae = Array(5)
          .fill(null)
          .map(() => createNebula());
      });

      // --- Initial Draw ---
      uiElements.startScreen.style.display = "flex";
      uiElements.gameOverScreen.style.display = "none";
      uiElements.scoreContainer.style.opacity = "0";
      width = canvas.width = window.innerWidth;
      height = canvas.height = window.innerHeight;
      ctx.fillStyle = "#050510";
      ctx.fillRect(0, 0, width, height);
      nebulae = Array(5)
        .fill(null)
        .map(() => createNebula());
      nebulae.forEach((n) => {
        ctx.fillStyle = n;
        ctx.fillRect(0, 0, width, height);
      });
      stars = [];
      for (let i = 0; i < 3; i++) {
        const layer = (i + 1) / 3;
        for (let j = 0; j < 80; j++)
          stars.push(
            new Star(
              Math.random() * width,
              Math.random() * height,
              Math.random() * 1.5 * layer,
              layer
            )
          );
      }
      stars.forEach((s) => s.draw());
      uiElements.highscoreDisplay.innerText = `High Score: ${
        localStorage.getItem(GAME_CONFIG.advanced.localStorageKey) || 0
      }`;
    </script>
  </body>
</html>
